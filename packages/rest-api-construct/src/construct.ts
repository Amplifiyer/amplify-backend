import { Construct } from 'constructs';
import {
  RestApi,
  Resource,
  Method,
  AuthorizationType,
  CognitoUserPoolsAuthorizer,
  LambdaIntegration,
  MockIntegration,
  PassthroughBehavior,
  MethodOptions,
  IAuthorizer,
  Integration,
} from 'aws-cdk-lib/aws-apigateway';
import { Stack, Tags } from 'aws-cdk-lib';
import { UserPool } from 'aws-cdk-lib/aws-cognito';
import {
  BackendOutputStorageStrategy,
  ResourceProvider,
  RestApiResources,
} from '@aws-amplify/plugin-types';
import { RestApiOutput, restApiOutputKey } from '@aws-amplify/backend-output-schemas';
import { AttributionMetadataStorage } from '@aws-amplify/backend-output-storage';
import * as path from 'path';
import { AuthConfig, EndpointConfig, HttpMethod, PathConfig, RestApiProps } from './types.js';

// Be very careful editing this value. It is the string that is used to attribute stacks to Amplify REST API in BI metrics
const restApiStackType = 'rest-api-ApiGateway';

/**
 * Amplify REST API CDK Construct
 */
export class AmplifyRestApi
  extends Construct
  implements ResourceProvider<RestApiResources>
{
  /**
   * The resources generated by the construct
   */
  readonly resources: RestApiResources;

  private readonly restApi: RestApi;
  private readonly rootResource: Resource;
  private readonly resources: Record<string, Resource> = {};
  private readonly methods: Record<string, Method> = {};
  private readonly name: string;
  private readonly userPool?: UserPool;
  private readonly authorizer?: IAuthorizer;

  /**
   * Create a new REST API construct
   */
  constructor(
    scope: Construct,
    id: string,
    props: RestApiProps,
    userPool?: UserPool,
    outputStorageStrategy?: BackendOutputStorageStrategy,
  ) {
    super(scope, id);
    this.name = props.name ?? 'AmplifyRestApi';
    this.userPool = userPool;

    // Create the REST API
    this.restApi = new RestApi(this, `${this.name}RestApi`, {
      restApiName: this.name,
      description: props.description,
      defaultCorsPreflightOptions: {
        allowOrigins: ['*'],
        allowMethods: ['GET', 'POST', 'PUT', 'DELETE', 'PATCH', 'OPTIONS', 'HEAD'],
        allowHeaders: ['Content-Type', 'X-Amz-Date', 'Authorization', 'X-Api-Key', 'X-Amz-Security-Token'],
      },
    });

    this.rootResource = this.restApi.root;

    // Create Cognito authorizer if user pool is provided
    if (this.userPool) {
      this.authorizer = new CognitoUserPoolsAuthorizer(this, `${this.name}Authorizer`, {
        cognitoUserPools: [this.userPool],
      });
    }

    // Process paths and endpoints
    this.processPaths(props.paths, props.defaultAuthConfig);

    // Store resources
    this.resources = {
      restApi: this.restApi,
      rootResource: this.rootResource,
      resources: this.resources,
      methods: this.methods,
    };

    // Store output
    if (outputStorageStrategy) {
      this.storeOutput(outputStorageStrategy);
    }

    // Add attribution metadata
    new AttributionMetadataStorage().storeAttributionMetadata(
      Stack.of(this),
      restApiStackType,
      path.resolve(__dirname, '..', 'package.json'),
    );
  }

  /**
   * Process API paths and create resources and methods
   */
  private processPaths(
    paths: Record<string, PathConfig>,
    defaultAuthConfig?: AuthConfig,
  ): void {
    // Process each path
    for (const [pathKey, pathConfig] of Object.entries(paths)) {
      // Create or get resource for this path
      const resource = this.getOrCreateResource(pathKey);
      
      // Process endpoints for this path
      for (const endpoint of pathConfig.endpoints) {
        // Create method for this endpoint
        const method = this.createMethod(
          resource,
          endpoint,
          defaultAuthConfig,
        );
        
        // Store method reference
        const methodKey = `${pathKey}:${endpoint.method}`;
        this.methods[methodKey] = method;
      }
    }
  }

  /**
   * Get or create a resource for a path
   */
  private getOrCreateResource(pathKey: string): Resource {
    // If path already exists, return it
    if (this.resources[pathKey]) {
      return this.resources[pathKey];
    }

    // Handle root path
    if (pathKey === '/' || pathKey === '') {
      this.resources[pathKey] = this.rootResource;
      return this.rootResource;
    }

    // Split path into segments
    const segments = pathKey.split('/').filter(Boolean);
    let currentResource = this.rootResource;
    let currentPath = '';

    // Create resources for each segment
    for (const segment of segments) {
      currentPath += `/${segment}`;
      
      // If this segment already exists, use it
      if (this.resources[currentPath]) {
        currentResource = this.resources[currentPath];
        continue;
      }

      // Create new resource for this segment
      const resource = currentResource.addResource(segment);
      this.resources[currentPath] = resource;
      currentResource = resource;
    }

    return currentResource;
  }

  /**
   * Create a method for an endpoint
   */
  private createMethod(
    resource: Resource,
    endpoint: EndpointConfig,
    defaultAuthConfig?: AuthConfig,
  ): Method {
    // Determine authorization type and options
    const methodOptions = this.getMethodOptions(
      endpoint.auth || defaultAuthConfig,
    );

    // Create integration
    const integration = this.createIntegration(endpoint);

    // Create method
    return resource.addMethod(endpoint.method, integration, methodOptions);
  }

  /**
   * Get method options based on auth config
   */
  private getMethodOptions(authConfig?: AuthConfig): MethodOptions {
    // Default to requiring authentication
    const requireAuth = authConfig?.requireAuthentication !== false;
    const allowGuests = authConfig?.allowGuests === true;
    
    // If no auth is required or guests are allowed, use NONE auth type
    if (!requireAuth || allowGuests) {
      return {
        authorizationType: AuthorizationType.NONE,
      };
    }

    // If we have a user pool and authorizer, use Cognito auth
    if (this.userPool && this.authorizer) {
      const options: MethodOptions = {
        authorizationType: AuthorizationType.COGNITO,
        authorizer: this.authorizer,
      };

      // If specific groups are required, add authorization scopes
      if (authConfig?.groups && authConfig.groups.length > 0) {
        // Validate that the groups exist in the user pool
        // This is a placeholder for validation logic that would be implemented
        // in the backend-rest-api package when it has access to the auth construct

        // Add authorization scopes for the groups
        options.authorizationScopes = authConfig.groups.map(
          (group) => `${this.userPool!.userPoolId}/group/${group}`
        );
      }

      return options;
    }

    // Default to no auth if no user pool is available
    return {
      authorizationType: AuthorizationType.NONE,
    };
  }

  /**
   * Create an integration for an endpoint
   */
  private createIntegration(endpoint: EndpointConfig): Integration {
    // Lambda integration
    if (endpoint.integration.function) {
      return new LambdaIntegration(endpoint.integration.function);
    }

    // Mock integration
    if (endpoint.integration.mock) {
      const { statusCode = '200', responseTemplates = {} } = endpoint.integration.mock;
      
      // Default response template if none provided
      if (!responseTemplates['application/json']) {
        responseTemplates['application/json'] = JSON.stringify({
          message: 'This is a mock integration',
        });
      }

      return new MockIntegration({
        integrationResponses: [
          {
            statusCode,
            responseTemplates,
          },
        ],
        passthroughBehavior: PassthroughBehavior.NEVER,
        requestTemplates: {
          'application/json': JSON.stringify({ statusCode }),
        },
      });
    }

    // Default to mock integration if none specified
    return new MockIntegration({
      integrationResponses: [
        {
          statusCode: '200',
          responseTemplates: {
            'application/json': JSON.stringify({
              message: 'Default mock integration',
            }),
          },
        },
      ],
      passthroughBehavior: PassthroughBehavior.NEVER,
      requestTemplates: {
        'application/json': JSON.stringify({ statusCode: 200 }),
      },
    });
  }

  /**
   * Store output for client generation
   */
  private storeOutput(outputStorageStrategy: BackendOutputStorageStrategy): void {
    const output: RestApiOutput = {
      restApiId: this.restApi.restApiId,
      restApiEndpoint: this.restApi.url,
      region: Stack.of(this).region,
    };

    outputStorageStrategy.storeOutput({
      resourceType: restApiOutputKey,
      resourceName: this.name,
      output,
    });
  }
}